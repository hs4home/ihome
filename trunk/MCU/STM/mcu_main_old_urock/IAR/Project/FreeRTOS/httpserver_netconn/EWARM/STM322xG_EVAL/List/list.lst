###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/Sep/2014  17:06:37
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\list.c
#    Command line =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\list.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM322xG_EVAL -lcN
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\
#        -o
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2x7_ETH_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM322xG_EVAL\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\lwip\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\netif\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\ipv4\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\FreeRTOS\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\portable\IAR\ARM_CM3\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\include\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\list.lst
#    Object file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\list.o
#
###############################################################################

C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\list.c
      1          /*
      2              FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
      3          
      4              FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
      5              http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS tutorial books are available in pdf and paperback.        *
     10               *    Complete, revised, and edited pdf reference manuals are also       *
     11               *    available.                                                         *
     12               *                                                                       *
     13               *    Purchasing FreeRTOS documentation will not only help you, by       *
     14               *    ensuring you get running as quickly as possible and with an        *
     15               *    in-depth knowledge of how to use FreeRTOS, it will also help       *
     16               *    the FreeRTOS project to continue with its mission of providing     *
     17               *    professional grade, cross platform, de facto standard solutions    *
     18               *    for microcontrollers - completely free of charge!                  *
     19               *                                                                       *
     20               *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
     21               *                                                                       *
     22               *    Thank you for using FreeRTOS, and thank you for your support!      *
     23               *                                                                       *
     24              ***************************************************************************
     25          
     26          
     27              This file is part of the FreeRTOS distribution.
     28          
     29              FreeRTOS is free software; you can redistribute it and/or modify it under
     30              the terms of the GNU General Public License (version 2) as published by the
     31              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     32          
     33              >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
     34              distribute a combined work that includes FreeRTOS without being obliged to
     35              provide the source code for proprietary components outside of the FreeRTOS
     36              kernel.
     37          
     38              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     39              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     40              FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
     41              details. You should have received a copy of the GNU General Public License
     42              and the FreeRTOS license exception along with FreeRTOS; if not it can be
     43              viewed here: http://www.freertos.org/a00114.html and also obtained by
     44              writing to Real Time Engineers Ltd., contact details for whom are available
     45              on the FreeRTOS WEB site.
     46          
     47              1 tab == 4 spaces!
     48          
     49              ***************************************************************************
     50               *                                                                       *
     51               *    Having a problem?  Start by reading the FAQ "My application does   *
     52               *    not run, what could be wrong?"                                     *
     53               *                                                                       *
     54               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     55               *                                                                       *
     56              ***************************************************************************
     57          
     58          
     59              http://www.FreeRTOS.org - Documentation, books, training, latest versions, 
     60              license and Real Time Engineers Ltd. contact details.
     61          
     62              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     63              including FreeRTOS+Trace - an indispensable productivity tool, and our new
     64              fully thread aware and reentrant UDP/IP stack.
     65          
     66              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High 
     67              Integrity Systems, who sell the code with commercial support, 
     68              indemnification and middleware, under the OpenRTOS brand.
     69              
     70              http://www.SafeRTOS.com - High Integrity Systems also provide a safety 
     71              engineered and independently SIL3 certified version for use in safety and 
     72              mission critical applications that require provable dependability.
     73          */
     74          
     75          
     76          #include <stdlib.h>
     77          #include "FreeRTOS.h"
     78          #include "list.h"
     79          
     80          /*-----------------------------------------------------------
     81           * PUBLIC LIST API documented in list.h
     82           *----------------------------------------------------------*/
     83          
     84          void vListInitialise( xList *pxList )
     85          {
     86          	/* The list structure contains a list item which is used to mark the
     87          	end of the list.  To initialise the list the list end is inserted
     88          	as the only list entry. */
     89          	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     90          
     91          	/* The list end value is the highest possible value in the list to
     92          	ensure it remains at the end of the list. */
     93          	pxList->xListEnd.xItemValue = portMAX_DELAY;
     94          
     95          	/* The list end next and previous pointers point to itself so we know
     96          	when the list is empty. */
     97          	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     98          	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     99          
    100          	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    101          }
    102          /*-----------------------------------------------------------*/
    103          
    104          void vListInitialiseItem( xListItem *pxItem )
    105          {
    106          	/* Make sure the list item is not recorded as being on a list. */
    107          	pxItem->pvContainer = NULL;
    108          }
    109          /*-----------------------------------------------------------*/
    110          
    111          void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
    112          {
    113          volatile xListItem * pxIndex;
    114          
    115          	/* Insert a new list item into pxList, but rather than sort the list,
    116          	makes the new list item the last item to be removed by a call to
    117          	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
    118          	the pxIndex member. */
    119          	pxIndex = pxList->pxIndex;
    120          
    121          	pxNewListItem->pxNext = pxIndex->pxNext;
    122          	pxNewListItem->pxPrevious = pxList->pxIndex;
    123          	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    124          	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    125          	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    126          
    127          	/* Remember which list the item is in. */
    128          	pxNewListItem->pvContainer = ( void * ) pxList;
    129          
    130          	( pxList->uxNumberOfItems )++;
    131          }
    132          /*-----------------------------------------------------------*/
    133          
    134          void vListInsert( xList *pxList, xListItem *pxNewListItem )
    135          {
    136          volatile xListItem *pxIterator;
    137          portTickType xValueOfInsertion;
    138          
    139          	/* Insert the new list item into the list, sorted in ulListItem order. */
    140          	xValueOfInsertion = pxNewListItem->xItemValue;
    141          
    142          	/* If the list already contains a list item with the same item value then
    143          	the new list item should be placed after it.  This ensures that TCB's which
    144          	are stored in ready lists (all of which have the same ulListItem value)
    145          	get an equal share of the CPU.  However, if the xItemValue is the same as
    146          	the back marker the iteration loop below will not end.  This means we need
    147          	to guard against this by checking the value first and modifying the
    148          	algorithm slightly if necessary. */
    149          	if( xValueOfInsertion == portMAX_DELAY )
    150          	{
    151          		pxIterator = pxList->xListEnd.pxPrevious;
    152          	}
    153          	else
    154          	{
    155          		/* *** NOTE ***********************************************************
    156          		If you find your application is crashing here then likely causes are:
    157          			1) Stack overflow -
    158          			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
    159          			2) Incorrect interrupt priority assignment, especially on Cortex-M3
    160          			   parts where numerically high priority values denote low actual
    161          			   interrupt priories, which can seem counter intuitive.  See
    162          			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
    163          			3) Calling an API function from within a critical section or when
    164          			   the scheduler is suspended.
    165          			4) Using a queue or semaphore before it has been initialised or
    166          			   before the scheduler has been started (are interrupts firing
    167          			   before vTaskStartScheduler() has been called?).
    168          		See http://www.freertos.org/FAQHelp.html for more tips.
    169          		**********************************************************************/
    170          
    171          		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    172          		{
    173          			/* There is nothing to do here, we are just iterating to the
    174          			wanted insertion position. */
    175          		}
    176          	}
    177          
    178          	pxNewListItem->pxNext = pxIterator->pxNext;
    179          	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    180          	pxNewListItem->pxPrevious = pxIterator;
    181          	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    182          
    183          	/* Remember which list the item is in.  This allows fast removal of the
    184          	item later. */
    185          	pxNewListItem->pvContainer = ( void * ) pxList;
    186          
    187          	( pxList->uxNumberOfItems )++;
    188          }
    189          /*-----------------------------------------------------------*/
    190          
    191          unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
    192          {
    193          xList * pxList;
    194          
    195          	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    196          	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    197          
    198          	/* The list item knows which list it is in.  Obtain the list from the list
    199          	item. */
    200          	pxList = ( xList * ) pxItemToRemove->pvContainer;
    201          
    202          	/* Make sure the index is left pointing to a valid item. */
    203          	if( pxList->pxIndex == pxItemToRemove )
    204          	{
    205          		pxList->pxIndex = pxItemToRemove->pxPrevious;
    206          	}
    207          
    208          	pxItemToRemove->pvContainer = NULL;
    209          	( pxList->uxNumberOfItems )--;
    210          
    211          	return pxList->uxNumberOfItems;
    212          }
    213          /*-----------------------------------------------------------*/
    214          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   uxListRemove
       0   vListInitialise
       0   vListInitialiseItem
       4   vListInsert
       0   vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      42  uxListRemove
      30  vListInitialise
       6  vListInitialiseItem
      60  vListInsert
      30  vListInsertEnd

 
 168 bytes in section .text
 
 168 bytes of CODE memory

Errors: none
Warnings: none
