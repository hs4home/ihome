###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        26/Sep/2014  17:06:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\croutine.c
#    Command line =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\croutine.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_STM322xG_EVAL -lcN
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\
#        -o
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0_2\arm\INC\c\DLib_Config_Full.h" -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F2xx\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Libraries\STM32F2x7_ETH_Driver\inc\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM322xG_EVAL\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\lwip\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\netif\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\src\include\ipv4\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\lwip_v1.3.2\port\STM32F2x7\FreeRTOS\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\portable\IAR\ARM_CM3\
#        -I
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\..\..\..\..\Utilities\Third_Party\FreeRTOS_v7.4.2\include\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0_2\arm\CMSIS\Include\"
#    List file    =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\List\croutine.lst
#    Object file  =  
#        C:\ihome\MCU\STM\trunk\mcu_main\IAR\Project\FreeRTOS\httpserver_netconn\EWARM\STM322xG_EVAL\Obj\croutine.o
#
###############################################################################

C:\ihome\MCU\STM\trunk\mcu_main\IAR\Utilities\Third_Party\FreeRTOS_v7.4.2\croutine.c
      1          /*
      2              FreeRTOS V7.4.2 - Copyright (C) 2013 Real Time Engineers Ltd.
      3          
      4              FEATURES AND PORTS ARE ADDED TO FREERTOS ALL THE TIME.  PLEASE VISIT
      5              http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              ***************************************************************************
      8               *                                                                       *
      9               *    FreeRTOS tutorial books are available in pdf and paperback.        *
     10               *    Complete, revised, and edited pdf reference manuals are also       *
     11               *    available.                                                         *
     12               *                                                                       *
     13               *    Purchasing FreeRTOS documentation will not only help you, by       *
     14               *    ensuring you get running as quickly as possible and with an        *
     15               *    in-depth knowledge of how to use FreeRTOS, it will also help       *
     16               *    the FreeRTOS project to continue with its mission of providing     *
     17               *    professional grade, cross platform, de facto standard solutions    *
     18               *    for microcontrollers - completely free of charge!                  *
     19               *                                                                       *
     20               *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
     21               *                                                                       *
     22               *    Thank you for using FreeRTOS, and thank you for your support!      *
     23               *                                                                       *
     24              ***************************************************************************
     25          
     26          
     27              This file is part of the FreeRTOS distribution.
     28          
     29              FreeRTOS is free software; you can redistribute it and/or modify it under
     30              the terms of the GNU General Public License (version 2) as published by the
     31              Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
     32          
     33              >>>>>>NOTE<<<<<< The modification to the GPL is included to allow you to
     34              distribute a combined work that includes FreeRTOS without being obliged to
     35              provide the source code for proprietary components outside of the FreeRTOS
     36              kernel.
     37          
     38              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     39              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     40              FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
     41              details. You should have received a copy of the GNU General Public License
     42              and the FreeRTOS license exception along with FreeRTOS; if not it can be
     43              viewed here: http://www.freertos.org/a00114.html and also obtained by
     44              writing to Real Time Engineers Ltd., contact details for whom are available
     45              on the FreeRTOS WEB site.
     46          
     47              1 tab == 4 spaces!
     48          
     49              ***************************************************************************
     50               *                                                                       *
     51               *    Having a problem?  Start by reading the FAQ "My application does   *
     52               *    not run, what could be wrong?"                                     *
     53               *                                                                       *
     54               *    http://www.FreeRTOS.org/FAQHelp.html                               *
     55               *                                                                       *
     56              ***************************************************************************
     57          
     58          
     59              http://www.FreeRTOS.org - Documentation, books, training, latest versions,
     60              license and Real Time Engineers Ltd. contact details.
     61          
     62              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     63              including FreeRTOS+Trace - an indispensable productivity tool, and our new
     64              fully thread aware and reentrant UDP/IP stack.
     65          
     66              http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
     67              Integrity Systems, who sell the code with commercial support,
     68              indemnification and middleware, under the OpenRTOS brand.
     69          
     70              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     71              engineered and independently SIL3 certified version for use in safety and
     72              mission critical applications that require provable dependability.
     73          */
     74          
     75          #include "FreeRTOS.h"
     76          #include "task.h"
     77          #include "croutine.h"
     78          
     79          /*
     80           * Some kernel aware debuggers require data to be viewed to be global, rather
     81           * than file scope.
     82           */
     83          #ifdef portREMOVE_STATIC_QUALIFIER
     84          	#define static
     85          #endif
     86          
     87          
     88          /* Lists for ready and blocked co-routines. --------------------*/
     89          static xList pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
     90          static xList xDelayedCoRoutineList1;									/*< Delayed co-routines. */
     91          static xList xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
     92          static xList * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
     93          static xList * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
     94          static xList xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
     95          
     96          /* Other file private variables. --------------------------------*/
     97          corCRCB * pxCurrentCoRoutine = NULL;
     98          static unsigned portBASE_TYPE uxTopCoRoutineReadyPriority = 0;
     99          static portTickType xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
    100          
    101          /* The initial state of the co-routine when it is created. */
    102          #define corINITIAL_STATE	( 0 )
    103          
    104          /*
    105           * Place the co-routine represented by pxCRCB into the appropriate ready queue
    106           * for the priority.  It is inserted at the end of the list.
    107           *
    108           * This macro accesses the co-routine ready lists and therefore must not be
    109           * used from within an ISR.
    110           */
    111          #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
    112          {																													\
    113          	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
    114          	{																												\
    115          		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
    116          	}																												\
    117          	vListInsertEnd( ( xList * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
    118          }
    119          
    120          /*
    121           * Utility to ready all the lists used by the scheduler.  This is called
    122           * automatically upon the creation of the first co-routine.
    123           */
    124          static void prvInitialiseCoRoutineLists( void );
    125          
    126          /*
    127           * Co-routines that are readied by an interrupt cannot be placed directly into
    128           * the ready lists (there is no mutual exclusion).  Instead they are placed in
    129           * in the pending ready list in order that they can later be moved to the ready
    130           * list by the co-routine scheduler.
    131           */
    132          static void prvCheckPendingReadyList( void );
    133          
    134          /*
    135           * Macro that looks at the list of co-routines that are currently delayed to
    136           * see if any require waking.
    137           *
    138           * Co-routines are stored in the queue in the order of their wake time -
    139           * meaning once one co-routine has been found whose timer has not expired
    140           * we need not look any further down the list.
    141           */
    142          static void prvCheckDelayedList( void );
    143          
    144          /*-----------------------------------------------------------*/
    145          
    146          signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
    147          {
    148          signed portBASE_TYPE xReturn;
    149          corCRCB *pxCoRoutine;
    150          
    151          	/* Allocate the memory that will store the co-routine control block. */
    152          	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    153          	if( pxCoRoutine )
    154          	{
    155          		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
    156          		be created and the co-routine data structures need initialising. */
    157          		if( pxCurrentCoRoutine == NULL )
    158          		{
    159          			pxCurrentCoRoutine = pxCoRoutine;
    160          			prvInitialiseCoRoutineLists();
    161          		}
    162          
    163          		/* Check the priority is within limits. */
    164          		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    165          		{
    166          			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    167          		}
    168          
    169          		/* Fill out the co-routine control block from the function parameters. */
    170          		pxCoRoutine->uxState = corINITIAL_STATE;
    171          		pxCoRoutine->uxPriority = uxPriority;
    172          		pxCoRoutine->uxIndex = uxIndex;
    173          		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    174          
    175          		/* Initialise all the other co-routine control block parameters. */
    176          		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    177          		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    178          
    179          		/* Set the co-routine control block as a link back from the xListItem.
    180          		This is so we can get back to the containing CRCB from a generic item
    181          		in a list. */
    182          		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    183          		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    184          
    185          		/* Event lists are always in priority order. */
    186          		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    187          
    188          		/* Now the co-routine has been initialised it can be added to the ready
    189          		list at the correct priority. */
    190          		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    191          
    192          		xReturn = pdPASS;
    193          	}
    194          	else
    195          	{
    196          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    197          	}
    198          
    199          	return xReturn;
    200          }
    201          /*-----------------------------------------------------------*/
    202          
    203          void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
    204          {
    205          portTickType xTimeToWake;
    206          
    207          	/* Calculate the time to wake - this may overflow but this is
    208          	not a problem. */
    209          	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    210          
    211          	/* We must remove ourselves from the ready list before adding
    212          	ourselves to the blocked list as the same list item is used for
    213          	both lists. */
    214          	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    215          
    216          	/* The list item will be inserted in wake time order. */
    217          	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    218          
    219          	if( xTimeToWake < xCoRoutineTickCount )
    220          	{
    221          		/* Wake time has overflowed.  Place this item in the
    222          		overflow list. */
    223          		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    224          	}
    225          	else
    226          	{
    227          		/* The wake time has not overflowed, so we can use the
    228          		current block list. */
    229          		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    230          	}
    231          
    232          	if( pxEventList )
    233          	{
    234          		/* Also add the co-routine to an event list.  If this is done then the
    235          		function must be called with interrupts disabled. */
    236          		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    237          	}
    238          }
    239          /*-----------------------------------------------------------*/
    240          
    241          static void prvCheckPendingReadyList( void )
    242          {
    243          	/* Are there any co-routines waiting to get moved to the ready list?  These
    244          	are co-routines that have been readied by an ISR.  The ISR cannot access
    245          	the	ready lists itself. */
    246          	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    247          	{
    248          		corCRCB *pxUnblockedCRCB;
    249          
    250          		/* The pending ready list can be accessed by an ISR. */
    251          		portDISABLE_INTERRUPTS();
    252          		{
    253          			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    254          			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    255          		}
    256          		portENABLE_INTERRUPTS();
    257          
    258          		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    259          		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    260          	}
    261          }
    262          /*-----------------------------------------------------------*/
    263          
    264          static void prvCheckDelayedList( void )
    265          {
    266          corCRCB *pxCRCB;
    267          
    268          	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    269          	while( xPassedTicks )
    270          	{
    271          		xCoRoutineTickCount++;
    272          		xPassedTicks--;
    273          
    274          		/* If the tick count has overflowed we need to swap the ready lists. */
    275          		if( xCoRoutineTickCount == 0 )
    276          		{
    277          			xList * pxTemp;
    278          
    279          			/* Tick count has overflowed so we need to swap the delay lists.  If there are
    280          			any items in pxDelayedCoRoutineList here then there is an error! */
    281          			pxTemp = pxDelayedCoRoutineList;
    282          			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    283          			pxOverflowDelayedCoRoutineList = pxTemp;
    284          		}
    285          
    286          		/* See if this tick has made a timeout expire. */
    287          		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    288          		{
    289          			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    290          
    291          			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    292          			{
    293          				/* Timeout not yet expired. */
    294          				break;
    295          			}
    296          
    297          			portDISABLE_INTERRUPTS();
    298          			{
    299          				/* The event could have occurred just before this critical
    300          				section.  If this is the case then the generic list item will
    301          				have been moved to the pending ready list and the following
    302          				line is still valid.  Also the pvContainer parameter will have
    303          				been set to NULL so the following lines are also valid. */
    304          				uxListRemove( &( pxCRCB->xGenericListItem ) );
    305          
    306          				/* Is the co-routine waiting on an event also? */
    307          				if( pxCRCB->xEventListItem.pvContainer )
    308          				{
    309          					uxListRemove( &( pxCRCB->xEventListItem ) );
    310          				}
    311          			}
    312          			portENABLE_INTERRUPTS();
    313          
    314          			prvAddCoRoutineToReadyQueue( pxCRCB );
    315          		}
    316          	}
    317          
    318          	xLastTickCount = xCoRoutineTickCount;
    319          }
    320          /*-----------------------------------------------------------*/
    321          
    322          void vCoRoutineSchedule( void )
    323          {
    324          	/* See if any co-routines readied by events need moving to the ready lists. */
    325          	prvCheckPendingReadyList();
    326          
    327          	/* See if any delayed co-routines have timed out. */
    328          	prvCheckDelayedList();
    329          
    330          	/* Find the highest priority queue that contains ready co-routines. */
    331          	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    332          	{
    333          		if( uxTopCoRoutineReadyPriority == 0 )
    334          		{
    335          			/* No more co-routines to check. */
    336          			return;
    337          		}
    338          		--uxTopCoRoutineReadyPriority;
    339          	}
    340          
    341          	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
    342          	 of the	same priority get an equal share of the processor time. */
    343          	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    344          
    345          	/* Call the co-routine. */
    346          	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    347          
    348          	return;
    349          }
    350          /*-----------------------------------------------------------*/
    351          
    352          static void prvInitialiseCoRoutineLists( void )
    353          {
    354          unsigned portBASE_TYPE uxPriority;
    355          
    356          	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    357          	{
    358          		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    359          	}
    360          
    361          	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    362          	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    363          	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    364          
    365          	/* Start with pxDelayedCoRoutineList using list1 and the
    366          	pxOverflowDelayedCoRoutineList using list2. */
    367          	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    368          	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    369          }
    370          /*-----------------------------------------------------------*/
    371          
    372          signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
    373          {
    374          corCRCB *pxUnblockedCRCB;
    375          signed portBASE_TYPE xReturn;
    376          
    377          	/* This function is called from within an interrupt.  It can only access
    378          	event lists and the pending ready list.  This function assumes that a
    379          	check has already been made to ensure pxEventList is not empty. */
    380          	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    381          	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    382          	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    383          
    384          	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    385          	{
    386          		xReturn = pdTRUE;
    387          	}
    388          	else
    389          	{
    390          		xReturn = pdFALSE;
    391          	}
    392          
    393          	return xReturn;
    394          }
    395          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvCheckDelayedList
         8   -> ulPortSetInterruptMask
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortClearInterruptMask
         8   -> xTaskGetTickCount
       8   prvCheckPendingReadyList
         8   -> ulPortSetInterruptMask
         8   -> uxListRemove
         8   -> vListInsertEnd
         8   -> vPortClearInterruptMask
       8   prvInitialiseCoRoutineLists
         8   -> vListInitialise
      16   vCoRoutineAddToDelayedList
        16   -> uxListRemove
        16   -> vListInsert
       8   vCoRoutineSchedule
         8   -- Indirect call
         8   -> prvCheckDelayedList
         8   -> prvCheckPendingReadyList
      24   xCoRoutineCreate
        24   -> prvInitialiseCoRoutineLists
        24   -> pvPortMalloc
        24   -> vListInitialiseItem
        24   -> vListInsertEnd
      16   xCoRoutineRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     174  prvCheckDelayedList
      78  prvCheckPendingReadyList
      58  prvInitialiseCoRoutineLists
       4  pxCurrentCoRoutine
       4  pxDelayedCoRoutineList
       4  pxOverflowDelayedCoRoutineList
      40  pxReadyCoRoutineLists
       4  uxTopCoRoutineReadyPriority
      88  vCoRoutineAddToDelayedList
     112  vCoRoutineSchedule
     158  xCoRoutineCreate
      54  xCoRoutineRemoveFromEventList
       4  xCoRoutineTickCount
      20  xDelayedCoRoutineList1
      20  xDelayedCoRoutineList2
       4  xLastTickCount
       4  xPassedTicks
      20  xPendingReadyCoRoutineList

 
 128 bytes in section .bss
 766 bytes in section .text
 
 766 bytes of CODE memory
 128 bytes of DATA memory

Errors: none
Warnings: none
